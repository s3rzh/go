package main

import (
	"fmt"
	"sync"
	"time"
)

// sync.Cond можно использовать для уведомления горутин о конкретных событиях или изменениях в системе.
// Например, вы можете использовать горутины, ожидающие определенного события. 
// Когда событие происходит, горутина сигнализации может использовать cond.Signal() или cond.Broadcast() чтобы разбудить ожидающие горутины и позволить им обработать событие.

const maxWorkersCount = 10

func main() {
	var counter int32
	var wg sync.WaitGroup
	var mu sync.Mutex
	cond := sync.NewCond(&mu)

	wg.Add(maxWorkersCount)

	for i := range maxWorkersCount {
		go func(workerID int) {
			defer wg.Done()
			fmt.Printf("Worker %d performing work\n", workerID)
			time.Sleep(1 * time.Second) // Simulate work
			cond.L.Lock()
			defer cond.L.Unlock()
			counter++
			if counter == maxWorkersCount {
				fmt.Println("All workers have reached the barrier")
				cond.Broadcast()
			} else {
				fmt.Printf("Worker %d is waiting at the barrier\n", workerID)
				cond.Wait()
			}
			fmt.Printf("Worker %d passed the barrier\n", workerID)
		}(i)
	}

	wg.Wait()
}

// Здесь у нас есть несколько рабочих горутин, которые выполняют работу и синхронизируются в барьерной точке. 
// Рабочие горутины увеличивают счетчик, а затем либо ждут у барьера, либо сигнализируют барьеру с помощью cond.Wait() и cond.Broadcast() в зависимости от количества рабочих, достигших барьера.

// Каждая рабочая горутина выполняет некоторую работу, а затем получает блокировку для увеличения переменной счетчика. 
// Если текущий рабочий процесс последним достиг барьера, он передает состояние барьера с помощью cond.Broadcast() чтобы разбудить всех ожидающих рабочих процессов. 
// В противном случае он ожидает у барьера, используя cond.Wait() чтобы получить уведомление от последнего работника.

// Синхронизация барьера гарантирует, что все рабочие горутины достигнут барьера до того, как какая-либо из них выйдет за его пределы. 
// Это может быть полезно в сценариях, требующих синхронизации выполнения нескольких горутин в определенной точке их рабочего процесса.

// Обратите внимание, что в этом примере барьер реализован с использованием простого счетчика. 
// Однако в более сложных сценариях вам может потребоваться рассмотреть дополнительные механизмы или условия синхронизации, чтобы обеспечить правильную синхронизацию и избежать состояний гонки.
