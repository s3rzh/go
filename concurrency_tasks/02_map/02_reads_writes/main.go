package main

import (
	"fmt"
	"sync"
)

// find&fix bug with reads-writes
func main() {
	storage := make(map[int]int, 1000)

	wg := &sync.WaitGroup{}
	reads := 1000
	writes := 1000
	mu := sync.Mutex{}

	wg.Add(writes)
	for i := 0; i < writes; i++ {
		i := i
		go func() {
			defer wg.Done()

			mu.Lock()
			defer mu.Unlock()
			storage[i] = i
		}()
	}
	wg.Add(reads)
	for i := 0; i < reads; i++ {
		i := i
		go func() {
			defer wg.Done()

			_, _ = storage[i]
		}()
	}

	wg.Wait()
	fmt.Println(storage)
}

// Данный пример запускается, но периодически!

// В данном примере мы создали правильную мапу.
// Планируем делать чтение и запись.
// При записи мы добавили блокировку, а при чтении нет.
// Чтение - операция безопасная, поэтому мьютекса нет.
// Операция чтения она безопасная, но только не при совместной записи.
// Горутины, которые пишут пересекаются с горутинами, которые читают.
// Можно просто взять бловировку для записи и вставить ее в цикле для чтения
// Это помогает справиться с ошибками, но эту можно сделать еще лучше
// использовать sync.RWMutex{} вместо sync.Mutex{}, в этом случае у нас появится методы RLock и RUnlock

// В чем отличие?
// Когда мы делаем Lock, то все, кто хотят взять блокировку ждут нас,
// а мы ждем того, кто сейчас владеет блокировкой и наоборот
// когда мы владеем блокировкой все ждут нас.
// RLock - это запрос именно на чтение, если у нас горутины на запись не пишут,
// но очень много горутин на чтение читают они никак не конфликтуют и блокировка
// намного менее тяжелая и можно быстрее читать
// Как только придет горутина, которая захочет сделать блокировку на запись, она будет ждать
// пока все блокировки взятые на чтение пройдут и сделают Unlock и тогда она сможет сделать
// свой Lock и сделать запись, и только когда произойдет разблокировка после записи, 
// горутины на чтение смогут начать читать
